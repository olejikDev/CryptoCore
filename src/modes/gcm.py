#!/usr/bin/env python3"""GCM (Galois/Counter Mode) implementation."""import osimport struct# Проверьте правильный импорт AEStry:    from src.algorithms.aes import AESexcept ImportError:    try:        from src.cipher import AES    except ImportError:        # Fallback для тестирования        from Crypto.Cipher import AES as PyCryptodomeAES        class AES:            def __init__(self, key):                self.cipher = PyCryptodomeAES.new(key, PyCryptodomeAES.MODE_ECB)            def encrypt_block(self, data):                return self.cipher.encrypt(data)class AuthenticationError(Exception):    """Исключение для ошибок аутентификации GCM"""    passclass GCM:    def __init__(self, key, nonce=None):        """        Инициализация GCM с ключом и nonce        Args:            key (bytes): Ключ AES (16, 24 или 32 байта)            nonce (bytes): Nonce (рекомендуется 12 байт)        """        self.aes = AES(key)        self.key = key        # Стандартный размер nonce для GCM - 12 байт        if nonce is None:            self.nonce = os.urandom(12)        else:            self.nonce = nonce        # Предвычисленная таблица для умножения в GF(2^128)        self._h = None  # Будет вычислен при первом использовании        self._table = None  # Исправлено: было self.table, должно быть self._table        self._table_computed = False        # Константы        self.block_size = 16  # Размер блока AES        self.r = 0xE1000000000000000000000000000000  # Полином    def _ensure_table_computed(self):        """Убедиться что таблица вычислена"""        if not self._table_computed:            self._compute_table()    def _compute_table(self):        """Вычисление таблицы для умножения в GF(2^128)"""        # H = E_K(0^128)        h_bytes = self.aes.encrypt_block(bytes(16))        self._h = self._bytes_to_int(h_bytes)        # Предвычисление таблицы - упрощенная версия        self._table = [0] * 16        self._table[0] = 0        self._table[1] = self._h        for i in range(2, 16, 2):            self._table[i] = self._mul2(self._table[i // 2])            self._table[i + 1] = self._int_xor(self._table[i], self._table[1])        self._table_computed = True    def _bytes_to_int(self, data):        """Конвертация байтов в целое число (big-endian)"""        return int.from_bytes(data, byteorder='big')    def _int_to_bytes(self, num, length=16):        """Конвертация целого числа в байты (big-endian)"""        return num.to_bytes(length, byteorder='big')    def _int_xor(self, a, b):        """XOR двух целых чисел"""        return a ^ b    def _mul2(self, x):        """Умножение на 2 в GF(2^128)"""        if x & (1 << 127):            return ((x << 1) & ((1 << 128) - 1)) ^ self.r        else:            return (x << 1) & ((1 << 128) - 1)    def _mul_gf_simple(self, x, y):        """Простое умножение в GF(2^128) без таблиц"""        z = 0        v = y        for i in range(127, -1, -1):            if (x >> i) & 1:                z ^= v            if v & 1:                v = (v >> 1) ^ self.r            else:                v >>= 1        return z    def _mul_gf(self, x, y):        """Умножение в GF(2^128) с использованием таблицы"""        self._ensure_table_computed()        # Простая реализация, так как табличная сложна        return self._mul_gf_simple(x, y)    def _ghash(self, aad, ciphertext):        """Вычисление GHASH"""        self._ensure_table_computed()        # Подготовка данных        len_aad = len(aad)        len_ct = len(ciphertext)        # Выравнивание данных до границы 16 байт        aad_padded = aad + bytes((-len_aad) % 16)        ct_padded = ciphertext + bytes((-len_ct) % 16)        # Инициализация        y = 0        # Обработка AAD        for i in range(0, len(aad_padded), 16):            block = aad_padded[i:i + 16]            y = self._int_xor(y, self._bytes_to_int(block))            y = self._mul_gf(y, self._h)        # Обработка ciphertext        for i in range(0, len(ct_padded), 16):            block = ct_padded[i:i + 16]            y = self._int_xor(y, self._bytes_to_int(block))            y = self._mul_gf(y, self._h)        # Добавление длин (64 бита каждая)        len_block = struct.pack('>QQ', len_aad * 8, len_ct * 8)        y = self._int_xor(y, self._bytes_to_int(len_block))        y = self._mul_gf(y, self._h)        return y    def _generate_initial_counter(self):        """Генерация начального значения счётчика из nonce"""        if len(self.nonce) == 12:            # Для 12-байтного nonce: J0 = nonce || 0x00000001            return self.nonce + b'\x00\x00\x00\x01'        else:            # Для других размеров nonce: GHASH(nonce || padding)            # Упрощенная реализация            nonce_padded = self.nonce + bytes((-len(self.nonce)) % 16)            len_block = struct.pack('>Q', len(self.nonce) * 8)            # Простое преобразование для тестирования            result = bytearray(16)            for i, b in enumerate(nonce_padded[:16]):                result[i] = b            for i, b in enumerate(len_block[:8]):                result[8 + i] = b            return bytes(result)    def encrypt(self, plaintext, aad=b""):        """        Шифрование с аутентификацией        Args:            plaintext (bytes): Данные для шифрования            aad (bytes): Ассоциированные данные (не шифруются)        Returns:            bytes: nonce + ciphertext + tag        """        # Генерация начального счётчика        j0 = self._generate_initial_counter()        # Убедимся что таблица вычислена        self._ensure_table_computed()        # Шифрование в CTR режиме        # Начальное значение счетчика для шифрования (J0 + 1)        try:            ctr_val = self._bytes_to_int(j0) + 1        except:            # Если не получается преобразовать, используем упрощенный подход            ctr_val = 1        ciphertext = bytearray()        for i in range(0, len(plaintext), self.block_size):            # Блок счетчика            ctr_block = ctr_val.to_bytes(16, 'big')            keystream = self.aes.encrypt_block(ctr_block)            # XOR с открытым текстом            block = plaintext[i:i + self.block_size]            encrypted = bytes(a ^ b for a, b in zip(block, keystream[:len(block)]))            ciphertext.extend(encrypted)            # Увеличение счетчика            ctr_val += 1        ciphertext = bytes(ciphertext)        # Вычисление тега аутентификации        s = self.aes.encrypt_block(j0)        s_int = self._bytes_to_int(s)        ghash_result = self._ghash(aad, ciphertext)        tag_int = self._int_xor(ghash_result, s_int)        tag = self._int_to_bytes(tag_int)        if len(tag) > 16:            tag = tag[:16]        elif len(tag) < 16:            tag = tag.ljust(16, b'\x00')        # Возвращаем nonce + ciphertext + tag        return self.nonce + ciphertext + tag    def decrypt(self, data, aad=b""):        """        Расшифрование с проверкой аутентификации        Args:            data (bytes): nonce + ciphertext + tag            aad (bytes): Ассоциированные данные        Returns:            bytes: Расшифрованный текст        Raises:            AuthenticationError: Если аутентификация не удалась        """        if len(data) < 12 + 16:  # minimum: nonce(12) + tag(16)            raise AuthenticationError("Данные слишком короткие")        # Извлечение компонентов        nonce = data[:12]        tag = data[-16:]        ciphertext = data[12:-16]        # Установка nonce для проверки        self.nonce = nonce        # Генерация начального счётчика        j0 = self._generate_initial_counter()        # Убедимся что таблица вычислена        self._ensure_table_computed()        # Вычисление ожидаемого тега        s = self.aes.encrypt_block(j0)        s_int = self._bytes_to_int(s)        ghash_result = self._ghash(aad, ciphertext)        expected_tag_int = self._int_xor(ghash_result, s_int)        expected_tag = self._int_to_bytes(expected_tag_int)        if len(expected_tag) > 16:            expected_tag = expected_tag[:16]        elif len(expected_tag) < 16:            expected_tag = expected_tag.ljust(16, b'\x00')        # Проверка тега (постоянная по времени)        if not self._constant_time_compare(tag, expected_tag):            raise AuthenticationError("Ошибка аутентификации: неверный тег")        # Расшифрование в CTR режиме        # Начальное значение счетчика для расшифрования (J0 + 1)        try:            ctr_val = self._bytes_to_int(j0) + 1        except:            ctr_val = 1        plaintext = bytearray()        for i in range(0, len(ciphertext), self.block_size):            # Блок счетчика            ctr_block = ctr_val.to_bytes(16, 'big')            keystream = self.aes.encrypt_block(ctr_block)            # XOR с шифртекстом            block = ciphertext[i:i + self.block_size]            decrypted = bytes(a ^ b for a, b in zip(block, keystream[:len(block)]))            plaintext.extend(decrypted)            # Увеличение счетчика            ctr_val += 1        return bytes(plaintext)    def _constant_time_compare(self, a, b):        """Сравнение с постоянным временем для предотвращения timing attacks"""        if len(a) != len(b):            return False        result = 0        for x, y in zip(a, b):            result |= x ^ y        return result == 0# Для тестированияif __name__ == "__main__":    # Простой тест    import sys    key = os.urandom(16)    plaintext = b"Hello, GCM World!"    aad = b"Additional authenticated data"    try:        gcm = GCM(key)        print("GCM инициализирован успешно")        ciphertext = gcm.encrypt(plaintext, aad)        print(f"Шифрование успешно, размер: {len(ciphertext)} байт")        gcm2 = GCM(key, gcm.nonce)        decrypted = gcm2.decrypt(ciphertext, aad)        print(f"Original: {plaintext}")        print(f"Decrypted: {decrypted}")        print(f"Match: {plaintext == decrypted}")    except Exception as e:        print(f"Ошибка: {type(e).__name__}: {e}")        import traceback        traceback.print_exc()        sys.exit(1)