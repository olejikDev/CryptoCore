#!/usr/bin/env python3"""PBKDF2 (Password-Based Key Derivation Function 2) implementation."""import hashlibimport hmacdef pbkdf2_hmac_sha1(password, salt, iterations, dklen):    """    PBKDF2 with HMAC-SHA1 as per RFC 6070.    Args:        password: The password as bytes or string        salt: The salt as bytes or string        iterations: Number of iterations        dklen: Desired key length in bytes    Returns:        Derived key as bytes    """    # Convert to bytes if needed    if isinstance(password, str):        password = password.encode('utf-8')    if isinstance(salt, str):        salt = salt.encode('utf-8')    # SHA-1 produces 20-byte output    hlen = 20    blocks_needed = (dklen + hlen - 1) // hlen    derived_key = b''    for i in range(1, blocks_needed + 1):        # U1 = HMAC-SHA1(password, salt || INT_32_BE(i))        block = hmac.new(password, salt + i.to_bytes(4, 'big'), hashlib.sha1).digest()        u_prev = block        # Compute U2 through Uc        for j in range(2, iterations + 1):            u_curr = hmac.new(password, u_prev, hashlib.sha1).digest()            # XOR u_curr into block            block = bytes(a ^ b for a, b in zip(block, u_curr))            u_prev = u_curr        derived_key += block    # Return exactly dklen bytes    return derived_key[:dklen]def pbkdf2_hmac_sha256(password, salt, iterations, dklen):    """    PBKDF2 with HMAC-SHA256.    Args:        password: The password as bytes or string        salt: The salt as bytes or string        iterations: Number of iterations        dklen: Desired key length in bytes    Returns:        Derived key as bytes    """    # Convert to bytes if needed    if isinstance(password, str):        password = password.encode('utf-8')    if isinstance(salt, str):        salt = salt.encode('utf-8')    # SHA-256 produces 32-byte output    hlen = 32    blocks_needed = (dklen + hlen - 1) // hlen    derived_key = b''    for i in range(1, blocks_needed + 1):        # U1 = HMAC-SHA256(password, salt || INT_32_BE(i))        block = hmac.new(password, salt + i.to_bytes(4, 'big'), hashlib.sha256).digest()        u_prev = block        # Compute U2 through Uc        for j in range(2, iterations + 1):            u_curr = hmac.new(password, u_prev, hashlib.sha256).digest()            # XOR u_curr into block            block = bytes(a ^ b for a, b in zip(block, u_curr))            u_prev = u_curr        derived_key += block    # Return exactly dklen bytes    return derived_key[:dklen]def pbkdf2_custom(password, salt, iterations, dklen, hash_func=hashlib.sha256):    """    Общая реализация PBKDF2 с поддержкой различных хэш-функций.    Args:        password: Пароль в виде байтов или строки        salt: Соль в виде байтов или строки        iterations: Количество итераций        dklen: Желаемая длина ключа в байтах        hash_func: Функция хэширования (по умолчанию SHA-256)    Returns:        bytes: Производный ключ    """    # Конвертируем в байты если нужно    if isinstance(password, str):        password = password.encode('utf-8')    if isinstance(salt, str):        salt = salt.encode('utf-8')    # Получаем длину вывода хэш-функции    hlen = hash_func().digest_size    blocks_needed = (dklen + hlen - 1) // hlen    derived_key = b''    for i in range(1, blocks_needed + 1):        # U1 = HMAC(password, salt || INT_32_BE(i))        block = hmac.new(password, salt + i.to_bytes(4, 'big'), hash_func).digest()        u_prev = block        # Compute U2 through Uc        for j in range(2, iterations + 1):            u_curr = hmac.new(password, u_prev, hash_func).digest()            # XOR u_curr into block            block = bytes(a ^ b for a, b in zip(block, u_curr))            u_prev = u_curr        derived_key += block    # Return exactly dklen bytes    return derived_key[:dklen]def verify_implementation():    """    Проверяет корректность реализации PBKDF2 путем сравнения с известными тестовыми векторами.    Returns:        bool: True если все тесты пройдены, False в противном случае    """    import hashlib    print("\n" + "=" * 60)    print("Проверка реализации PBKDF2")    print("=" * 60)    test_cases = [        {            'description': 'RFC 6070 Vector 1 (HMAC-SHA1)',            'password': b'password',            'salt': b'salt',            'iterations': 1,            'dklen': 20,            'expected': bytes.fromhex('0c60c80f961f0e71f3a9b524af6012062fe037a6'),            'hash': hashlib.sha1        },        {            'description': 'RFC 6070 Vector 2 (HMAC-SHA1)',            'password': b'password',            'salt': b'salt',            'iterations': 2,            'dklen': 20,            'expected': bytes.fromhex('ea6c014dc72d6f8ccd1ed92ace1d41f0d8de8957'),            'hash': hashlib.sha1        },        {            'description': 'RFC 6070 Vector 3 (HMAC-SHA1)',            'password': b'password',            'salt': b'salt',            'iterations': 4096,            'dklen': 20,            'expected': bytes.fromhex('4b007901b765489abead49d926f721d065a429c1'),            'hash': hashlib.sha1        },        {            'description': 'Basic SHA-256 test',            'password': b'test',            'salt': b'salt',            'iterations': 1,            'dklen': 32,            'expected': None,  # Будет сравниваться с нашей же реализацией            'hash': hashlib.sha256        }    ]    all_passed = True    passed_count = 0    total_count = len(test_cases)    for i, test in enumerate(test_cases):        print(f"\nТест {i + 1}/{total_count}: {test['description']}")        # Вычисляем PBKDF2        result = pbkdf2_custom(test['password'], test['salt'],                               test['iterations'], test['dklen'],                               test['hash'])        # Проверяем результат        if test['expected'] is not None:            # Сравниваем с ожидаемым значением            if result == test['expected']:                print(f"  ✓ Пройден")                passed_count += 1            else:                print(f"  ✗ Не пройден")                print(f"    Ожидалось: {test['expected'].hex()}")                print(f"    Получено:  {result.hex()}")                all_passed = False        else:            # Для теста без ожидаемого значения просто проверяем длину            if len(result) == test['dklen']:                print(f"  ✓ Пройден (длина корректна: {len(result)} байт)")                passed_count += 1            else:                print(f"  ✗ Не пройден (неправильная длина: {len(result)} байт вместо {test['dklen']})")                all_passed = False    print("\n" + "=" * 60)    print(f"Результат: {passed_count}/{total_count} тестов пройдено")    if all_passed:        print("✓ Все тесты пройдены успешно!")    else:        print("✗ Некоторые тесты не пройдены")    print("=" * 60)    return all_passeddef generate_salt(salt_size=16):    """    Генерирует случайную соль.    Args:        salt_size: Размер соли в байтах (по умолчанию 16)    Returns:        bytes: Случайная соль    """    import os    return os.urandom(salt_size)def derive_key_from_password(password, salt=None, iterations=100000, dklen=32,                             hash_func=hashlib.sha256):    """    Удобная функция для получения ключа из пароля.    Args:        password: Пароль (строка)        salt: Соль (байты). Если None, генерируется автоматически.        iterations: Количество итераций        dklen: Длина ключа в байтах        hash_func: Функция хэширования    Returns:        tuple: (derived_key, salt_used)    """    if salt is None:        salt = generate_salt()    if isinstance(password, str):        password = password.encode('utf-8')    derived_key = pbkdf2_custom(password, salt, iterations, dklen, hash_func)    return derived_key, salt# Если файл запущен напрямую, выполняем проверкуif __name__ == "__main__":    print("Запуск проверки реализации PBKDF2...")    success = verify_implementation()    if success:        print("\n✓ Реализация PBKDF2 корректна")        exit(0)    else:        print("\n✗ Обнаружены проблемы в реализации PBKDF2")        exit(1)