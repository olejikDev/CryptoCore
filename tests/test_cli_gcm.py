#!/usr/bin/env python3"""Интеграционные тесты для CLI с GCM"""import osimport subprocessimport tempfileimport unittestclass TestCLIGCM(unittest.TestCase):    """Тесты CLI с GCM режимом"""    def setUp(self):        """Настройка тестов"""        self.test_data = b"Test data for CLI GCM testing"        self.key = "00112233445566778899aabbccddeeff"        self.aad = "aabbccddeeff00112233445566778899"    def run_command(self, cmd):        """Запуск команды и возврат результата"""        result = subprocess.run(            cmd, shell=True, capture_output=True, text=True        )        return result.returncode, result.stdout, result.stderr    def test_cli_gcm_encrypt_decrypt(self):        """Тест CLI: GCM шифрование и расшифрование согласно M6"""        print("\n=== Test 1: CLI GCM encryption/decryption ===")        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as plain_file:            plain_file.write(self.test_data)            plain_path = plain_file.name        encrypted_path = plain_path + '.enc'        decrypted_path = plain_path + '.dec'        try:            # 1. Шифрование с AAD (используем субкоманду encrypt с флагом --encrypt)            cmd = (f"python cryptocore.py encrypt --algorithm aes --mode gcm --encrypt "                   f"--key {self.key} --input {plain_path} --output {encrypted_path} "                   f"--aad {self.aad}")            returncode, stdout, stderr = self.run_command(cmd)            print(f"Encryption command: {cmd}")            print(f"Return code: {returncode}")            print(f"Stdout: {stdout}")            print(f"Stderr: {stderr}")            self.assertEqual(returncode, 0, f"Encryption failed: {stderr}")            self.assertTrue(os.path.exists(encrypted_path))            # 2. Дешифрование с правильным AAD            cmd = (f"python cryptocore.py encrypt --algorithm aes --mode gcm --decrypt "                   f"--key {self.key} --input {encrypted_path} --output {decrypted_path} "                   f"--aad {self.aad}")            returncode, stdout, stderr = self.run_command(cmd)            print(f"\nDecryption command: {cmd}")            print(f"Return code: {returncode}")            print(f"Stdout: {stdout}")            print(f"Stderr: {stderr}")            self.assertEqual(returncode, 0, f"Decryption failed: {stderr}")            self.assertTrue(os.path.exists(decrypted_path))            # 3. Проверка данных            with open(decrypted_path, 'rb') as f:                decrypted_data = f.read()            self.assertEqual(decrypted_data, self.test_data)            print("✓ CLI GCM encryption/decryption test passed")        finally:            # Очистка            for path in [plain_path, encrypted_path, decrypted_path]:                if os.path.exists(path):                    try:                        os.remove(path)                    except:                        pass    def test_cli_gcm_auth_failure_wrong_aad(self):        """Тест CLI: неудача аутентификации GCM при неверном AAD"""        print("\n=== Test 2: CLI GCM authentication failure with wrong AAD ===")        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as plain_file:            plain_file.write(self.test_data)            plain_path = plain_file.name        encrypted_path = plain_path + '.enc'        decrypted_path = plain_path + '.dec'        try:            # 1. Шифрование с правильным AAD            cmd = (f"python cryptocore.py encrypt --algorithm aes --mode gcm --encrypt "                   f"--key {self.key} --input {plain_path} --output {encrypted_path} "                   f"--aad {self.aad}")            returncode, stdout, stderr = self.run_command(cmd)            self.assertEqual(returncode, 0, f"Encryption failed: {stderr}")            # 2. Пробуем дешифровать с неправильным AAD            wrong_aad = "ffffffffffffffffffffffffffffffff"            cmd = (f"python cryptocore.py encrypt --algorithm aes --mode gcm --decrypt "                   f"--key {self.key} --input {encrypted_path} --output {decrypted_path} "                   f"--aad {wrong_aad}")            returncode, stdout, stderr = self.run_command(cmd)            # Должен быть ненулевой код возврата при неудачной аутентификации            self.assertNotEqual(returncode, 0,                                "Should fail with wrong AAD but didn't")            # Проверяем сообщение об ошибке (если есть)            if stderr:                error_lower = stderr.lower()                # Проверяем как английские, так и русские ключевые слова                self.assertTrue(                    "authentication" in error_lower or                    "auth" in error_lower or                    "failed" in error_lower or                    "error" in error_lower or                    "ошибка" in error_lower or  # русский                    "аутентификац" in error_lower or  # русский                    "не удалась" in error_lower,  # русский                    f"Should show authentication error, got: {stderr}"                )            elif stdout:                # Также проверяем stdout на случай, если ошибка там                output_lower = stdout.lower()                self.assertTrue(                    "authentication" in output_lower or                    "auth" in output_lower or                    "failed" in output_lower or                    "error" in output_lower or                    "ошибка" in output_lower or  # русский                    "аутентификац" in output_lower or  # русский                    "не удалась" in output_lower,  # русский                    f"Should show authentication error, got: {stdout}"                )            # Файл не должен быть создан (согласно M6 стр.2)            self.assertFalse(os.path.exists(decrypted_path),                             "Output file should not be created on auth failure")            print("✓ CLI GCM authentication failure test passed")        finally:            # Очистка            for path in [plain_path, encrypted_path, decrypted_path]:                if os.path.exists(path):                    try:                        os.remove(path)                    except:                        pass    def test_cli_gcm_without_aad(self):        """Тест CLI: GCM без AAD (пустой AAD)"""        print("\n=== Test 3: CLI GCM without AAD ===")        with tempfile.NamedTemporaryFile(mode='wb', delete=False) as plain_file:            plain_file.write(self.test_data)            plain_path = plain_file.name        encrypted_path = plain_path + '.enc'        decrypted_path = plain_path + '.dec'        try:            # 1. Шифрование без AAD            cmd = (f"python cryptocore.py encrypt --algorithm aes --mode gcm --encrypt "                   f"--key {self.key} --input {plain_path} --output {encrypted_path}")            returncode, stdout, stderr = self.run_command(cmd)            self.assertEqual(returncode, 0, f"Encryption failed: {stderr}")            # 2. Дешифрование без AAD            cmd = (f"python cryptocore.py encrypt --algorithm aes --mode gcm --decrypt "                   f"--key {self.key} --input {encrypted_path} --output {decrypted_path}")            returncode, stdout, stderr = self.run_command(cmd)            self.assertEqual(returncode, 0, f"Decryption failed: {stderr}")            # 3. Проверка данных            with open(decrypted_path, 'rb') as f:                decrypted_data = f.read()            self.assertEqual(decrypted_data, self.test_data)            print("✓ CLI GCM without AAD test passed")        finally:            # Очистка            for path in [plain_path, encrypted_path, decrypted_path]:                if os.path.exists(path):                    try:                        os.remove(path)                    except:                        passif __name__ == "__main__":    print("Running CLI GCM tests...")    unittest.main(verbosity=2)